package htmx4s.example.lib

import cats.effect.*
import cats.syntax.all.*

import htmx4s.example.lib.Model.*

import _root_.doobie.*
import _root_.doobie.hikari.HikariTransactor
import _root_.doobie.implicits.*
import _root_.doobie.util.log.{LogEvent, Success}
import com.zaxxer.hikari.HikariConfig

private trait H2Database[F[_]]:
  def selectContacts(contains: Option[String], limit: Int, offset: Int): F[List[Contact]]
  def findByEmail(email: Email): F[Option[Contact]]
  def findById(id: Long): F[Option[Contact]]
  def insert(c: Contact): F[Long]
  def update(c: Contact): F[Boolean]
  def delete(id: Long): F[Boolean]
  def countAll: F[Long]

private object H2Database extends DoobieInstances:

  private def handler[F[_]: Sync]: LogHandler[F] =
    new LogHandler[F] {
      val logger = scribe.cats.effect[F]
      def run(e: LogEvent) = e match {
        case e @ Success(_, _, _, _, _) =>
          logger.trace("SQL success: " + e)
        case e =>
          if (e.label == "trace") logger.trace(s"SQL failure: $e")
          else logger.warn(s"SQL failure: $e")
      }
    }

  private def config(dir: String) = {
    val cfg = HikariConfig()
    val path = java.nio.file.Path.of(dir).toAbsolutePath
    cfg.setJdbcUrl(s"jdbc:h2:${path}/contact.db;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE")
    cfg.setMaximumPoolSize(4)
    cfg.setDriverClassName("org.h2.Driver")
    cfg.setUsername("sa")
    cfg.setPassword("sa")
    cfg
  }

  def create[F[_]: Async](dir: String = ""): Resource[F, H2Database[F]] =
    for {
      ta <- HikariTransactor.fromHikariConfig[F](config(dir), handler.some)
      s = Impl[F](ta)
      _ <- Resource.eval(s.initDB)
    } yield s

  private class Impl[F[_]: MonadCancelThrow](ta: Transactor[F]) extends H2Database[F]:
    def initDB: F[Unit] = {
      val createContact =
        sql"""create table if not exists contact (
            id bigint generated by default as identity not null primary key,
            first_name varchar not null,
            last_name varchar not null,
            email varchar unique,
            phone varchar
           )""".update.run
      createContact.transact(ta).void
    }

    val selectFrag = sql"select id, first_name, last_name, phone, email from contact "
    def countAll: F[Long] =
      sql"select count(id) from contact".query[Long].unique.transact(ta)

    def selectContacts(
        contains: Option[String],
        limit: Int,
        offset: Int
    ): F[List[Contact]] =
      val where = contains
        .map { c =>
          sql"where lower(first_name) like $c or lower(last_name) like $c or lower(email) like $c or lower(phone) like $c"
        }
        .getOrElse(Fragment.empty)
      (selectFrag ++ where ++ sql" order by last_name, first_name offset $offset rows fetch first $limit rows only")
        .query[Contact]
        .to[List]
        .transact(ta)

    def insert(c: Contact): F[Long] =
      sql"insert into contact (first_name,last_name,email,phone) values (${c.name.first}, ${c.name.last}, ${c.email}, ${c.phone})".update
        .withUniqueGeneratedKeys[Long]("id")
        .transact(ta)
    def update(c: Contact): F[Boolean] =
      sql"update contact set first_name = ${c.name.first}, last_name = ${c.name.last}, email = ${c.email}, phone = ${c.phone} where id = ${c.id}".update.run
        .map(_ > 0)
        .transact(ta)
    def delete(id: Long): F[Boolean] =
      sql"delete from contact where id = $id".update.run.map(_ > 0).transact(ta)
    def findByEmail(email: Email): F[Option[Contact]] =
      (selectFrag ++ sql" where email = $email")
        .query[Contact]
        .option
        .transact(ta)

    def findById(id: Long): F[Option[Contact]] =
      (selectFrag ++ sql" where id = $id")
        .query[Contact]
        .option
        .transact(ta)
